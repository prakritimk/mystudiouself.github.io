<!DOCTYPE html>
<html lang="en">
  <head>
      <title>Studious Elf | Triggers</title>
      
      <link rel="icon" href="finalog.jpg" sizes="80x60" type="image/jpg">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" type="text/css" href="css.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Dancing Script">
           <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Overlock">
      
      <style>
           p{
              font-family: 'Overlock';
          }
</style>
         <style> 
              p1{
              font-family: 'Overlock';
          }
           </style> 

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
      
<meta name="viewport" content="width=device-width, initial-scale=1">

 </head>
    <body style="background-color:bisque;">
      
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

      <nav>
          <ul class="menu">
          <li class="item button"><a href="signup.html"> Sign Up</a></li>
           <li class="item button"><a href="signin.html"> Sign In</a></li>
           <li class="item button"><a href="index.html.html">Home </a></li>
            <li class="item button"><a href="cursors.html">Cursors</a></li>
              <li class="toggle"><span class="bars"></span>
              </li>
          </ul>
      </nav>
        
        <h1 style="font-family:Dancing Script;font-size:300%; text-align: center">TRIGGERS</h1>
        
        <div class=cursors>
        
            <p style="text-align:justify">
A database trigger is procedural code that is automatically executed in response to certain events on a particular table or view in a database. The trigger is mostly used for maintaining the integrity of the information on the database. For example, when a new record (representing a new worker) is added to the employees table, new records should also be created in the tables of the taxes, vacations and salaries. Triggers can also be used to log historical data, for example to keep track of employees' previous salaries.<br>
Oracle:<br>
In addition to triggers that fire (and execute PL/SQL code) when data is modified, Oracle 10g supports triggers that fire when schema-level objects (that is, tables) are modified and when user logon or logoff events occur.
<br>
Schema-level triggers:<br>
1.After Creation<br>
2.Before Alter<br>
3.After Alter<br>
4.Before Drop<br>
5.After Drop<br>
6.Before Insert<br>
The four main types of triggers are:<br>
1.Row-level trigger: This gets executed before or after any column value of a row changes.<br>
2.Column-level trigger: This gets executed before or after the specified column changes.<br>
3.For each row type: This trigger gets executed once for each row of the result set affected by an insert/update/delete.<br>
4.For each statement type: This trigger gets executed only once for the entire result set, but also fires each time the statement is executed.<br>
System-level triggers:<br>
From Oracle 8i, database events - logons, logoffs, startups - can fire Oracle triggers.
<br>
Microsoft SQL Server:<br>
A list of all available firing events in Microsoft SQL Server for DDL triggers is available on Microsoft Docs.
Performing conditional actions in triggers (or testing data following modification) is done through accessing the temporary Inserted and Deleted tables.<br>

PostgreSQL<br>
Introduced support for triggers in 1997. The following functionality in SQL:2003 was previously not implemented in PostgreSQL:<br>

SQL allows triggers to fire on updates to specific columns; As of version 9.0 of PostgreSQL this feature is also implemented in PostgreSQL.<br>
The standard allows the execution of a number of SQL statements other than SELECT, INSERT, UPDATE, such as CREATE TABLE as the triggered action. This can be done through creating a stored procedure or function to call CREATE TABLE.<br>
Synopsis:<br>

CREATE TRIGGER name { BEFORE | AFTER } { event [ OR ... ] }<br>
    ON TABLE [ FOR [ EACH ] { ROW | STATEMENT } ]<br>
    EXECUTE PROCEDURE funcname ( arguments )<br>
Firebird:<br>
Firebird supports multiple row-level, BEFORE or AFTER, INSERT, UPDATE, DELETE (or any combination of thereof) triggers per table, where they are always "in addition to" the default table changes, and the order of the triggers relative to each other can be specified where it would otherwise be ambiguous (POSITION clause.) Triggers may also exist on views, where they are always "instead of" triggers, replacing the default updatable view logic. (Before version 2.1, triggers on views deemed updatable would run in addition to the default logic.)<br>

Firebird does not raise mutating table exceptions (like Oracle), and triggers will by default both nest and recurse as required (SQL Server allows nesting but not recursion, by default.) Firebird's triggers use NEW and OLD context variables (not Inserted and Deleted tables,) and provide UPDATING, INSERTING, and DELETING flags to indicate the current usage of the trigger.<br>

{CREATE | RECREATE | CREATE OR ALTER} TRIGGER name FOR {table name | view name}<br>
 [ACTIVE | INACTIVE]<br>
 {BEFORE | AFTER}<br>
 {INSERT [OR UPDATE] [OR DELETE] | UPDATE [OR INSERT] [OR DELETE] | DELETE [OR UPDATE] [OR INSERT] }<br>
 [POSITION n] AS<br>
BEGIN<br>
 ....<br>
END<br>
As of version 2.1, Firebird additionally supports the following database-level triggers:<br>

1.CONNECT (exceptions raised here prevent the connection from completing)<br>
2.DISCONNECT<br>
3.TRANSACTION START<br>
4.TRANSACTION COMMIT (exceptions raised here prevent the transaction from committing, or preparing if a two-phase commit is involved)<br>
5.TRANSACTION ROLLBACK<br>
6.Database-level triggers can help enforce multi-table constraints, or emulate materialized views. If an exception is raised in a TRANSACTION COMMIT trigger, the changes made by the trigger so far are rolled back and the client application is notified, but the transaction remains active as if COMMIT had never been requested; the client application can continue to make changes and re-request COMMIT.<br>
<br>
Syntax for database triggers:<br>

{CREATE | RECREATE | CREATE OR ALTER} TRIGGER name<br>
 [ACTIVE | INACTIVE] ON<br>
 {CONNECT | DISCONNECT | TRANSACTION START | TRANSACTION COMMIT | TRANSACTION ROLLBACK}<br>
 [POSITION n] AS<br>
BEGIN<br>
 .....<br>
END<br>
                <br>
MySQL/MariaDB<br>
Limited support for triggers in the MySQL/MariaDB DBMS was added in the 5.0 version of MySQL, launched in 2005.

As of version 8.0, they allow for DDL (Data Definition Language) triggers and for DML (Data Manipulation Language) triggers. They also allow either type of DDL trigger (AFTER or BEFORE) to be used to define triggers. They are created by using the clause CREATE TRIGGER and deleted by using the clause DROP TRIGGER. The statement called upon an event happens is defined after the clause FOR EACH ROW, followed by a keyword (SET or BEGIN), which indicates whether what follows is an expression or a statement respectively.<br>
<br>
IBM DB2 LUW:<br>
IBM DB2 for distributed systems known as DB2 for LUW (LUW means Linux, Unix, Windows) supports three trigger types: Before trigger, After trigger and Instead of trigger. Both statement level and row level triggers are supported. If there are more triggers for same operation on table then firing order is determined by trigger creation data. Since version 9.7 IBM DB2 supports autonomous transactions.<br>

Before trigger is for checking data and deciding if operation should be permitted. If exception is thrown from before trigger then operation is aborted and no data are changed. In DB2 before triggers are read only â€” you can't modify data in before triggers. After triggers are designed for post processing after requested change was performed. After triggers can write data into tables and unlike some[which?] other databases you can write into any table including table on which trigger operates. Instead of triggers are for making views writeable.<br>

Triggers are usually programmed in SQL PL language.<br>
<br>
SQLite<br>
CREATE [TEMP | TEMPORARY] TRIGGER [IF NOT EXISTS] [database_name .] trigger_name<br>
[BEFORE | AFTER | INSTEAD OF] {DELETE | INSERT | UPDATE [OF column_name [, column_name]...]} <br>
ON {table_name | view_name}<br>
   [FOR EACH ROW] [WHEN condition is mandatory ]<br>
BEGIN<br>
   ...<br>
END<br>
                <br>
SQLite only supports row-level triggers, not statement-level triggers.<br>

Updateable views, which are not supported in SQLite, can be emulated with INSTEAD OF triggers.<br>

XML databases:<br>
An example of implementation of triggers in non-relational database can be Sedna, that provides support for triggers based on XQuery. Triggers in Sedna were designed to be analogous to SQL:2003 triggers, but natively base on XML query and update languages (XPath, XQuery and XML update language).<br>

A trigger in Sedna is set on any nodes of an XML document stored in database. When these nodes are updated, the trigger automatically executes XQuery queries and updates specified in its body. For example, the following trigger cancels person node deletion if there are any open auctions referenced by this person:<br>

 CREATE TRIGGER "trigger3"<br>
     BEFORE DELETE<br>
     ON doc("auction")/site//person<br>
     FOR EACH NODE<br>
     DO<br>
     {<br>
        if(exists($WHERE//open_auction/bidder/personref/@person=$OLD/@id))<br>
        then ( )<br>
        else $OLD;<br>
     }<br>
Row and statement level triggers:<br>
To understand how trigger behavior works, you need to be aware of the two main types of triggers; these are Row and Statement level triggers. The distinction between the two is how many times the code within the trigger is executed, and at what time.<br>

Suppose you have a trigger that is made to be called on an UPDATE to a certain table. Row level triggers would execute once for each row that is affected by the UPDATE. It is important to keep in mind if no rows are affected by the UPDATE command, the trigger will not execute any code within the trigger. Statement level triggers will be called once regardless of how many rows are affected by the UPDATE. Here it is important to note that even if the UPDATE command didn't affect any rows, the code within the trigger will still be executed once.<br>

Using the BEFORE and AFTER options[7] determine when the trigger is called. Suppose you have a trigger that is called on an INSERT to a certain table. If your trigger is using the BEFORE option, the code within the trigger will be executed before the INSERT into the table occurs. A common use of the BEFORE trigger is to verify the input values of the INSERT, or modify the values accordingly. Now let's say we have a trigger that uses AFTER instead. The code within the trigger is executed after the INSERT happens to the table. An example use of this trigger is creating an audit history of who has made inserts into the database, keeping track of the changes made. When using these options you need to keep a few things in mind. The BEFORE option does not allow you to modify tables, that is why input validation is a practical use. Using AFTER triggers allows you to modify tables such as inserting into an audit history table.<br>

When creating a trigger to determine if it is statement or row level simply include the FOR EACH ROW clause for a row level, or omit the clause for a statement level. Be cautious of using additional INSERT/UPDATE/DELETE commands within your trigger, because trigger recursion is possible, causing unwanted behavior. In the examples below each trigger is modifying a different table, by looking at what is being modified you can see some common applications of when different trigger types are used.<br>

Here is an Oracle syntax example of a row level trigger that is called AFTER an update FOR EACH ROW affected. This trigger is called on an update to a phone book database. When the trigger is called it adds an entry into a separate table named phone_book_audit. Also take note of triggers being able to take advantage of schema objects like sequences,[8] in this example audit_id_sequence.nexVal is used to generate unique primary keys in the phone_book_audit table.<br>

CREATE OR REPLACE TRIGGER phone_book_audit<br>
  AFTER UPDATE ON phone_book FOR EACH ROW<br>
BEGIN<br>
  INSERT INTO phone_book_audit <br>
    (audit_id,audit_change, audit_l_name, audit_f_name, audit_old_phone_number, audit_new_phone_number, audit_date) <br>
    VALUES<br>
    (audit_id_sequence.nextVal,'Update', :OLD.last_name, :OLD.first_name, :OLD.phone_number, :NEW.phone_number, SYSDATE<br>
END;<br>
Now calling an UPDATE on the phone_book table for people with the last name 'Jones'.<br>

UPDATE phone_book SET phone_number = '111-111-1111' WHERE last_name = 'Jones';<br>
Audit_ID	Audit_Change	F_Name	L_Name	New_Phone_Number	Old_Phone_Number	Audit_Date<br>
1	Update	Jordan	Jones	111-111-1111	098-765-4321	02-MAY-14<br>
2	Update	Megan	Jones	111-111-1111	111-222-3456	02-MAY-14<br>
                <br>
G Notice that the phone_number_audit table is now populated with two entries. This is due to the database having two entries with the last name of 'Jones'. Since the update modified two separate row values, the created trigger was called twice; once after each modification.<br>

After - statement-level trigger<br>
An Oracle syntax statement trigger that is called after an UPDATE to the phone_book table. When the trigger gets called it makes an insert into phone_book_edit_history table<br>
<br>
CREATE OR REPLACE TRIGGER phone_book_history<br>
  AFTER UPDATE ON phone_book<br>
BEGIN<br>
  INSERT INTO phone_book_edit_history <br>
    (audit_history_id, username, modification, edit_date) <br>
    VALUES<br>
    (audit_history_id_sequence.nextVal, USER,'Update', SYSDATE);<br>
END;<br>
Now lets do exactly the same update as the above example, however this time we have a statement level trigger.<br>
<br>
UPDATE phone_book SET phone_number = '111-111-1111' WHERE last_name = 'Jones';<br>
Audit_History_ID	Username	Modification	Edit_Date<br>
1	HAUSCHBC	Update	02-MAY-14<br>
You can see that the trigger was only called once, even though the update did change two rows.<br>
<br>
Before each - row-level trigger:<br>
In this example we have a BEFORE EACH ROW trigger that modifies the INSERT using a WHEN conditional. If the last name is larger than 10 letters, using the SUBSTR function[9] we change the last_name column value to an abbreviation.
<br>
CREATE OR REPLACE TRIGGER phone_book_insert<br>
  BEFORE INSERT ON phone_book FOR EACH ROW<br>
  WHEN (LENGTH(new.last_name) > 10)<br>
BEGIN<br>
    :new.last_name := SUBSTR(:new.last_name,0,1);<br>
END;<br>
Now lets perform an INSERT of someone with a large name.<br>
<br>
INSERT INTO phone_book VALUES<br>
(6, 'VeryVeryLongLastName', 'Erin', 'Minneapolis', 'MN', '989 University Drive', '123-222-4456', 55408, TO_DATE('11/21/1991', 'MM/DD/YYYY'));<br>
Person_ID	Last_Name	First_Name	City	State_Abbreviation	Address	Phone_Number	Zip_code	DOB<br>
6	V	Erin	Minneapolis	MN	989 University Drive	123-222-4456	55408	21-NOV-91<br>
                <br>
You can see that the trigger worked, modifying the value of the INSERT before it was executed.<br>
<br>
Before - statement-level trigger:<br>
Using a BEFORE statement trigger is particularly useful when enforcing database restrictions.[10] For this example I am going to enforce a restriction upon someone named "SOMEUSER" on the table phone_book.<br>
<br>
CREATE OR REPLACE TRIGGER hauschbc <br>
  BEFORE INSERT ON SOMEUSER.phone_book<br>
BEGIN<br>
    RAISE_APPLICATION_ERROR (<br>
         num => -20050,<br>
         msg => 'Error message goes here.');<br>
END;<br>
Now when "SOMEUSER" is logged in after attempting any INSERT this error message will show:<br>
<br>
SQL Error: ORA-20050: Error message goes here.<br>
Custom errors such as this one has a restriction on what the num variable can be defined as. Because of the numerous other pre-defined errors this variable must be in the range of -20000 to -20999.<br>
            </p>
        </div>
    </body>
</html>
    